<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Draggable Ball</title>
  <style>
    body {
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #f0f0f0;
    }
    .container {
      position: relative;
      width: 500px;
      height: 500px;
      background-color: #fff;
      border: 2px solid #ccc;
      overflow: hidden;
    }
    .ball {
      position: absolute;
      width: 50px;
      height: 50px;
      background-color: red;
      border-radius: 50%;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="ball"></div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <script>
    const container = document.querySelector('.container');
    const ball = document.querySelector('.ball');

    let velocity = { x: 0, y: 0 };
    let lastPosition = { x: 0, y: 0 };
    let isDragging = false;

    const containerBounds = container.getBoundingClientRect();

    ball.addEventListener('mousedown', startDrag);
    window.addEventListener('mousemove', onDrag);
    window.addEventListener('mouseup', endDrag);

    function startDrag(e) {
      isDragging = true;
      lastPosition = { x: e.clientX, y: e.clientY };
      gsap.killTweensOf(ball); // Stop any current animations
    }

    function onDrag(e) {
      if (!isDragging) return;

      const dx = e.clientX - lastPosition.x;
      const dy = e.clientY - lastPosition.y;

      const ballBounds = ball.getBoundingClientRect();

      // Update position while respecting container bounds
      const newLeft = Math.min(
        Math.max(ballBounds.left + dx, containerBounds.left),
        containerBounds.right - ballBounds.width
      );
      const newTop = Math.min(
        Math.max(ballBounds.top + dy, containerBounds.top),
        containerBounds.bottom - ballBounds.height
      );

      gsap.set(ball, {
        x: newLeft - containerBounds.left,
        y: newTop - containerBounds.top,
      });

      velocity = { x: dx, y: dy };
      lastPosition = { x: e.clientX, y: e.clientY };
    }

    function endDrag() {
      if (!isDragging) return;
      isDragging = false;

      // Apply inertia
      gsap.to(ball, {
        x: `+=${velocity.x * 10}`,
        y: `+=${velocity.y * 10}`,
        duration: 1,
        ease: 'power2.out',
        onUpdate: checkBounds,
      });
    }

    function checkBounds() {
      const ballBounds = ball.getBoundingClientRect();

      if (ballBounds.left < containerBounds.left) {
        gsap.set(ball, { x: 0 });
        velocity.x = -velocity.x * 0.5;
      } else if (ballBounds.right > containerBounds.right) {
        gsap.set(ball, { x: containerBounds.width - ballBounds.width });
        velocity.x = -velocity.x * 0.5;
      }

      if (ballBounds.top < containerBounds.top) {
        gsap.set(ball, { y: 0 });
        velocity.y = -velocity.y * 0.5;
      } else if (ballBounds.bottom > containerBounds.bottom) {
        gsap.set(ball, { y: containerBounds.height - ballBounds.height });
        velocity.y = -velocity.y * 0.5;
      }
    }
  </script>
</body>
</html>
